"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const queues_1 = require("../src/queues");
test("LifoQueue `get` awaits for items in the queue", async () => {
    let result = -1;
    const queue = new queues_1.LifoQueue();
    setTimeout(() => {
        result = new Date().getTime();
        queue.push(result);
    }, 10);
    const value = await queue.get();
    expect(value).toBe(result);
    expect(value).toBeGreaterThan(-1);
});
test("LifoQueue resolves items in LIFO order", async (done) => {
    let result1 = -1;
    let result2 = -1;
    let result3 = -1;
    const queue = new queues_1.LifoQueue();
    setTimeout(() => {
        result1 = new Date().getTime();
        queue.push(result1);
    }, 10);
    setTimeout(() => {
        result2 = new Date().getTime();
        queue.push(result2);
    }, 20);
    setTimeout(async () => {
        result3 = new Date().getTime();
        queue.push(result3);
        const [value1, value2, value3] = await Promise.all([
            queue.get(),
            queue.get(),
            queue.get(),
        ]);
        expect(value1).toBe(result3);
        expect(value2).toBe(result2);
        expect(value3).toBe(result1);
        done();
    }, 30);
});
test("LifoQueue resolves `get` as soon as items are pushed", async () => {
    let result1 = -1;
    let result2 = -1;
    let result3 = -1;
    const queue = new queues_1.LifoQueue();
    setTimeout(() => {
        result1 = new Date().getTime();
        queue.push(result1);
    }, 10);
    setTimeout(() => {
        result2 = new Date().getTime();
        queue.push(result2);
    }, 20);
    setTimeout(() => {
        result3 = new Date().getTime();
        queue.push(result3);
    }, 30);
    const [value1, value2, value3] = await Promise.all([
        queue.get(),
        queue.get(),
        queue.get(),
    ]);
    expect(value1).toBe(result1);
    expect(value2).toBe(result2);
    expect(value3).toBe(result3);
});
test("LifoQueue returns first the last items in the queue", async () => {
    const queue = new queues_1.LifoQueue();
    queue.push(1);
    queue.push(2);
    queue.push(3);
    queue.push(4);
    queue.push(5);
    let value = await queue.get();
    expect(value).toBe(5);
    value = await queue.get();
    expect(value).toBe(4);
    queue.push(6);
    value = await queue.get();
    expect(value).toBe(6);
});
test("LifoQueue is clean when empty", async () => {
    const queue = new queues_1.LifoQueue();
    queue.push(1);
    queue.push(2);
    queue.push(3);
    expect(queue).toHaveLength(3);
    while (queue.length) {
        await queue.get();
    }
    expect(queue).toHaveLength(0);
});
test("LifoQueue length is the number of available items 1", async () => {
    let count = 200;
    const total = 200;
    const queue = new queues_1.LifoQueue();
    const promises = [];
    for (const _ of new Array(count)) {
        promises.push(queue.get());
    }
    expect(queue.length).toBe(-total);
    while (count) {
        count--;
        queue.push(count);
        expect(queue.length).toBe(count === 0 ? 0 : -count);
    }
    expect(queue).toHaveLength(0);
    const items = await Promise.all(promises);
    const expectedResult = Array.from(Array(total).keys()).reverse();
    expect(items).toEqual(expectedResult);
});
test("LifoQueue length is the number of available items 2", async () => {
    let count = 200;
    const total = 200;
    const queue = new queues_1.LifoQueue();
    const promises = [];
    for (const item of Array.from(Array(total).keys())) {
        queue.push(item);
        expect(queue.length).toBe(item + 1);
    }
    expect(queue.length).toBe(total);
    while (count) {
        count--;
        promises.push(queue.get());
        expect(queue.length).toBe(count);
    }
    expect(queue).toHaveLength(0);
    const items = await Promise.all(promises);
    const expectedResult = Array.from(Array(total).keys()).reverse();
    expect(items).toEqual(expectedResult);
});
test("LifoQueue length and pending", async (done) => {
    const calls = [];
    const total = 20;
    const queue = new queues_1.LifoQueue();
    const promises = [];
    for (const item of Array.from(Array(total).keys())) {
        queue.push(item);
    }
    expect(queue.length).toBe(total);
    expect(queue.pending).toBe(0);
    for (const _ of Array.from(Array(total * 3).keys())) {
        promises.push(queue.get());
    }
    expect(queue.length).toBe(total * -2);
    expect(queue.pending).toBe(total * 2);
    Promise.all(promises.slice(total * 2, total * 3)).then(() => {
        expect(queue).toHaveLength(0);
        expect(queue.pending).toBe(0);
        calls.push("C");
        expect(calls).toEqual(["A", "B", "C"]);
        done();
    });
    Promise.all(promises.slice(total, total * 2)).then((values) => {
        expect(queue.length).toBe(-total);
        expect(queue.pending).toBe(total);
        calls.push("B");
        for (const value of values) {
            queue.push(value);
        }
    });
    setTimeout(async () => {
        const firstTwenty = await Promise.all(promises.slice(0, 20));
        const expectedResult = Array.from(Array(total).keys()).reverse();
        expect(firstTwenty).toEqual(expectedResult);
        for (const value of firstTwenty) {
            queue.push(value);
        }
        calls.push("A");
    }, 20);
});
