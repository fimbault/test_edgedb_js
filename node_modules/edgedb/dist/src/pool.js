"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("./errors");
const queues_1 = require("./queues");
const client_1 = require("./client");
const ifaces_1 = require("./ifaces");
class Deferred {
    constructor() {
        this._done = false;
        this._reject = undefined;
        this._resolve = undefined;
        this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            this._resolve = (value) => {
                this._done = true;
                this._result = value;
                resolve(value);
            };
        });
    }
    get promise() {
        return this._promise;
    }
    get done() {
        return this._done;
    }
    get result() {
        if (!this._done) {
            throw new Error("The deferred is not resolved.");
        }
        return this._result;
    }
    async setResult(value) {
        while (!this._resolve) {
            await new Promise((resolve) => process.nextTick(resolve));
        }
        this._resolve(value);
    }
    async setFailed(reason) {
        while (!this._reject) {
            await new Promise((resolve) => process.nextTick(resolve));
        }
        this._reject(reason);
    }
}
exports.Deferred = Deferred;
class PoolConnectionHolder {
    constructor(pool, onAcquire, onRelease) {
        this._pool = pool;
        this._onAcquire = onAcquire;
        this._onRelease = onRelease;
        this._connection = null;
        this._proxy = null;
        this._inUse = null;
        this._generation = null;
    }
    get connection() {
        return this._connection;
    }
    get pool() {
        return this._pool;
    }
    getConnectionOrThrow() {
        if (this._connection === null) {
            throw new TypeError("The connection is not open");
        }
        return this._connection;
    }
    terminate() {
        if (this._connection !== null) {
            this._connection.close();
        }
    }
    async connect() {
        if (this._connection !== null) {
            throw new errors.ClientError("PoolConnectionHolder.connect() called while another " +
                "connection already exists");
        }
        this._connection = await this._pool.getNewConnection();
        this._generation = this._pool.generation;
    }
    async acquire() {
        var _a;
        if (this._connection === null || this._connection.isClosed()) {
            this._connection = null;
            await this.connect();
        }
        else if (this._generation !== this._pool.generation) {
            await this._connection.close();
            this._connection = null;
            await this.connect();
        }
        const proxy = new PoolConnectionProxy(this, this.getConnectionOrThrow());
        this._proxy = proxy;
        if (this._onAcquire) {
            try {
                await this._onAcquire(proxy);
            }
            catch (error) {
                await ((_a = this._connection) === null || _a === void 0 ? void 0 : _a.close());
                throw error;
            }
        }
        this._inUse = new Deferred();
        return proxy;
    }
    async release() {
        var _a, _b, _c;
        if (this._inUse === null) {
            throw new errors.ClientError("PoolConnectionHolder.release() called on " +
                "a free connection holder");
        }
        if ((_a = this._connection) === null || _a === void 0 ? void 0 : _a.isClosed()) {
            return;
        }
        if (this._generation !== this._pool.generation) {
            await ((_b = this._connection) === null || _b === void 0 ? void 0 : _b.close());
            return;
        }
        if (this._onRelease && this._proxy) {
            try {
                await this._onRelease(this._proxy);
            }
            catch (error) {
                await ((_c = this._connection) === null || _c === void 0 ? void 0 : _c.close());
                throw error;
            }
        }
        await this._release();
    }
    async _waitUntilReleased() {
        if (this._inUse === null) {
            return;
        }
        await this._inUse.promise;
    }
    async close() {
        if (this._connection !== null) {
            await this._connection.close();
        }
    }
    _releaseOnClose() {
        this._release();
        this._connection = null;
    }
    async _release() {
        if (this._inUse === null) {
            return;
        }
        if (!this._inUse.done) {
            await this._inUse.setResult();
        }
        this._inUse = null;
        if (this._proxy !== null) {
            this._proxy[detach]();
            this._proxy = null;
        }
        this._pool.enqueue(this);
    }
}
const holderAttr = Symbol.for("holder");
const detach = Symbol.for("detach");
exports.getHolder = Symbol.for("getHolder");
const connectionAttr = Symbol.for("connection");
exports.unwrapConnection = Symbol.for("unwrap");
const isDetached = Symbol.for("isDetached");
class PoolConnectionProxy {
    constructor(holder, connection) {
        this[holderAttr] = holder;
        this[connectionAttr] = connection;
        if (client_1.proxyMap.has(connection)) {
            throw new errors.InterfaceError("internal client error: the connection is already assigned to a proxy");
        }
        client_1.proxyMap.set(connection, this);
    }
    [exports.unwrapConnection]() {
        const conn = this[connectionAttr];
        if (conn === null) {
            throw new errors.InterfaceError("The proxy is detached");
        }
        return conn;
    }
    async execute(query) {
        await this[exports.unwrapConnection]().execute(query);
    }
    async transaction(action, options) {
        return await this[exports.unwrapConnection]().transaction(action, options);
    }
    async query(query, args) {
        return await this[exports.unwrapConnection]().query(query, args);
    }
    async queryJSON(query, args) {
        return await this[exports.unwrapConnection]().queryJSON(query, args);
    }
    async queryOne(query, args) {
        return await this[exports.unwrapConnection]().queryOne(query, args);
    }
    async queryOneJSON(query, args) {
        return await this[exports.unwrapConnection]().queryOneJSON(query, args);
    }
    close() {
        throw new errors.InterfaceError("The proxy cannot be closed");
    }
    [isDetached]() {
        return this[connectionAttr] === null;
    }
    isClosed() {
        const conn = this[connectionAttr];
        return conn === null || conn.isClosed();
    }
    [ifaces_1.onConnectionClose]() {
        this[holderAttr]._releaseOnClose();
    }
    [exports.getHolder]() {
        return this[holderAttr];
    }
    [detach]() {
        if (this[connectionAttr] === null) {
            return null;
        }
        const conn = this[connectionAttr];
        this[connectionAttr] = null;
        if (conn != null) {
            client_1.proxyMap.delete(conn);
        }
        return conn;
    }
}
exports.PoolConnectionProxy = PoolConnectionProxy;
const DefaultMinPoolSize = 0;
const DefaultMaxPoolSize = 100;
class PoolStats {
    constructor(queueLength, openConnections) {
        this._queueLength = queueLength;
        this._openConnections = openConnections;
    }
    get queueLength() {
        return this._queueLength;
    }
    get openConnections() {
        return this._openConnections;
    }
}
exports.PoolStats = PoolStats;
class PoolImpl {
    constructor(dsn, options = {}) {
        var _a;
        const { onAcquire, onRelease, onConnect, connectOptions } = options;
        const minSize = options.minSize === undefined ? DefaultMinPoolSize : options.minSize;
        const maxSize = options.maxSize === undefined ? DefaultMaxPoolSize : options.maxSize;
        this.validateSizeParameters(minSize, maxSize);
        this._queue = new queues_1.LifoQueue();
        this._holders = [];
        this._initialized = false;
        this._initializing = false;
        this._minSize = minSize;
        this._maxSize = maxSize;
        this._onAcquire = onAcquire;
        this._onRelease = onRelease;
        this._onConnect = onConnect;
        this._closing = false;
        this._closed = false;
        this._generation = 0;
        this._connectOptions = { ...connectOptions, dsn };
        this._connectionFactory = (_a = options.connectionFactory, (_a !== null && _a !== void 0 ? _a : client_1.default));
    }
    getStats() {
        return new PoolStats(this._queue.pending, this._holders.filter((holder) => holder.connection !== null && holder.connection.isClosed() === false).length);
    }
    get generation() {
        return this._generation;
    }
    enqueue(holder) {
        this._queue.push(holder);
    }
    static async create(dsn, options) {
        const pool = new PoolImpl(dsn, options || {});
        await pool.initialize();
        return pool;
    }
    validateSizeParameters(minSize, maxSize) {
        if (maxSize <= 0) {
            throw new errors.InterfaceError("maxSize is expected to be greater than zero");
        }
        if (minSize < 0) {
            throw new errors.InterfaceError("minSize is expected to be greater or equal to zero");
        }
        if (minSize > maxSize) {
            throw new errors.InterfaceError("minSize is greater than maxSize");
        }
    }
    async initialize() {
        if (this._initialized) {
            return;
        }
        if (this._initializing) {
            throw new errors.InterfaceError("The pool is already being initialized");
        }
        if (this._closed) {
            throw new errors.InterfaceError("The pool is closed");
        }
        this._initializing = true;
        for (let i = 0; i < this._maxSize; i++) {
            const connectionHolder = new PoolConnectionHolder(this, this._onAcquire, this._onRelease);
            this._holders.push(connectionHolder);
            this._queue.push(connectionHolder);
        }
        try {
            await this._initializeHolders();
        }
        finally {
            this._initialized = true;
            this._initializing = false;
        }
    }
    expireConnections() {
        this._generation += 1;
    }
    async _initializeHolders() {
        if (!this._minSize) {
            return;
        }
        const tasks = [];
        let count = 0;
        for (let i = this._holders.length - 1; i >= 0; i--) {
            if (count >= this._minSize) {
                break;
            }
            const connectionHolder = this._holders[i];
            tasks.push(connectionHolder.connect());
            count += 1;
        }
        await Promise.all(tasks);
    }
    async getNewConnection() {
        const connection = await this._connectionFactory(this._connectOptions.dsn, this._connectOptions);
        if (this._onConnect) {
            try {
                await this._onConnect(connection);
            }
            catch (error) {
                await connection.close();
                throw error;
            }
        }
        return connection;
    }
    _checkInit() {
        if (!this._initialized) {
            if (this._initializing) {
                throw new errors.InterfaceError("The pool is being initialized, but not yet ready: " +
                    "likely there is a race between creating a pool and " +
                    "using it");
            }
            throw new errors.InterfaceError("The pool is not initialized. Call the ``initialize`` method " +
                "before using it.");
        }
        if (this._closed) {
            throw new errors.InterfaceError("The pool is closed");
        }
    }
    async acquire() {
        if (this._closing) {
            throw new errors.InterfaceError("The pool is closing");
        }
        if (this._closed) {
            throw new errors.InterfaceError("The pool is closed");
        }
        this._checkInit();
        return await this._acquireConnectionProxy();
    }
    async _acquireConnectionProxy() {
        const connectionHolder = await this._queue.get();
        try {
            return await connectionHolder.acquire();
        }
        catch (error) {
            this._queue.push(connectionHolder);
            throw error;
        }
    }
    async release(connectionProxy) {
        if (!(connectionProxy instanceof PoolConnectionProxy)) {
            throw new Error("a connection obtained via pool.acquire() was expected");
        }
        if (connectionProxy[isDetached]()) {
            return;
        }
        const holder = connectionProxy[exports.getHolder]();
        if (holder.pool !== this) {
            throw new errors.InterfaceError("The connection proxy does not belong to this pool.");
        }
        this._checkInit();
        return await holder.release();
    }
    async run(action) {
        const proxy = await this.acquire();
        try {
            return await action(proxy);
        }
        finally {
            await this.release(proxy);
        }
    }
    async transaction(action, options) {
        throw new errors.InterfaceError("Operation not supported. Use a `transaction` on a specific db " +
            "connection. For example: pool.run((con) => {" +
            "con.transaction(() => {...})" +
            "})");
    }
    async execute(query) {
        return await this.run(async (connection) => {
            return await connection.execute(query);
        });
    }
    async query(query, args) {
        return await this.run(async (connection) => {
            return await connection.query(query, args);
        });
    }
    async queryJSON(query, args) {
        return await this.run(async (connection) => {
            return await connection.queryJSON(query, args);
        });
    }
    async queryOne(query, args) {
        return await this.run(async (connection) => {
            return await connection.queryOne(query, args);
        });
    }
    async queryOneJSON(query, args) {
        return await this.run(async (connection) => {
            return await connection.queryOneJSON(query, args);
        });
    }
    async close() {
        if (this._closed) {
            return;
        }
        this._checkInit();
        this._closing = true;
        const warningTimeoutId = setTimeout(() => {
            this._warn_on_long_close();
        }, 60e3);
        try {
            await Promise.all(this._holders.map((connectionHolder) => connectionHolder._waitUntilReleased()));
            await Promise.all(this._holders.map((connectionHolder) => connectionHolder.close()));
        }
        catch (error) {
            this.terminate();
            throw error;
        }
        finally {
            clearTimeout(warningTimeoutId);
            this._closed = true;
            this._closing = false;
        }
    }
    isClosed() {
        return this._closed;
    }
    terminate() {
        if (this._closed) {
            return;
        }
        this._checkInit();
        for (const connectionHolder of this._holders) {
            connectionHolder.terminate();
        }
        this._closed = true;
    }
    _warn_on_long_close() {
        console.warn("Pool.close() is taking over 60 seconds to complete. " +
            "Check if you have any unreleased connections left.");
    }
}
function createPool(dsn, options) {
    if (typeof dsn === "string") {
        return PoolImpl.create(dsn, options);
    }
    else {
        if (dsn != null) {
            console.warn("`options` as the first argument to `edgedb.connect` is " +
                "deprecated, use " +
                "`edgedb.connect('instance_name_or_dsn', options)`");
        }
        return PoolImpl.create(undefined, { ...dsn, ...options });
    }
}
exports.createPool = createPool;
