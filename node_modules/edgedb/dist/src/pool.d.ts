/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2020-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ConnectConfig } from "./con_utils";
import { Set } from "./datatypes/set";
import { QueryArgs, Connection, IConnectionProxied, Pool, IPoolStats, onConnectionClose, TransactionOptions } from "./ifaces";
export declare class Deferred<T> {
    private _promise;
    private _resolve?;
    private _reject?;
    private _result;
    private _done;
    get promise(): Promise<T>;
    get done(): boolean;
    get result(): T | PromiseLike<T> | undefined;
    setResult(value?: T | PromiseLike<T> | undefined): Promise<void>;
    setFailed(reason?: any): Promise<void>;
    constructor();
}
declare class PoolConnectionHolder {
    private _pool;
    private _proxy;
    private _onAcquire?;
    private _onRelease?;
    private _connection;
    private _generation;
    private _inUse;
    constructor(pool: PoolImpl, onAcquire?: (proxy: Connection) => Promise<void>, onRelease?: (proxy: Connection) => Promise<void>);
    get connection(): Connection | null;
    get pool(): PoolImpl;
    private getConnectionOrThrow;
    terminate(): void;
    connect(): Promise<void>;
    acquire(): Promise<PoolConnectionProxy>;
    release(): Promise<void>;
    close(): Promise<void>;
    private _release;
}
declare const holderAttr: unique symbol;
export declare const getHolder: unique symbol;
declare const connectionAttr: unique symbol;
export declare const unwrapConnection: unique symbol;
export declare class PoolConnectionProxy implements IConnectionProxied {
    private [holderAttr];
    private [connectionAttr];
    constructor(holder: PoolConnectionHolder, connection: Connection);
    private [unwrapConnection];
    execute(query: string): Promise<void>;
    transaction<T>(action: () => Promise<T>, options?: TransactionOptions): Promise<T>;
    query(query: string, args?: QueryArgs): Promise<Set>;
    queryJSON(query: string, args?: QueryArgs): Promise<string>;
    queryOne(query: string, args?: QueryArgs): Promise<any>;
    queryOneJSON(query: string, args?: QueryArgs): Promise<string>;
    close(): Promise<void>;
    isClosed(): boolean;
    [onConnectionClose](): void;
}
export interface PoolOptions {
    connectOptions?: ConnectConfig | null;
    minSize?: number;
    maxSize?: number;
    onAcquire?: (proxy: Connection) => Promise<void>;
    onRelease?: (proxy: Connection) => Promise<void>;
    onConnect?: (connection: Connection) => Promise<void>;
    connectionFactory?: (dsn: string | undefined, options?: ConnectConfig | null) => Promise<Connection>;
}
export declare class PoolStats implements IPoolStats {
    private _queueLength;
    private _openConnections;
    constructor(queueLength: number, openConnections: number);
    get queueLength(): number;
    get openConnections(): number;
}
declare class PoolImpl implements Pool {
    private _closed;
    private _closing;
    private _queue;
    private _holders;
    private _initialized;
    private _initializing;
    private _minSize;
    private _maxSize;
    private _onAcquire?;
    private _onRelease?;
    private _onConnect?;
    private _connectionFactory;
    private _generation;
    private _connectOptions;
    protected constructor(dsn?: string, options?: PoolOptions);
    getStats(): PoolStats;
    private validateSizeParameters;
    protected initialize(): Promise<void>;
    expireConnections(): void;
    private _initializeHolders;
    private _checkInit;
    acquire(): Promise<PoolConnectionProxy>;
    private _acquireConnectionProxy;
    release(connectionProxy: Connection): Promise<void>;
    run<T>(action: (connection: Connection) => Promise<T>): Promise<T>;
    transaction<T>(action: () => Promise<T>, options?: TransactionOptions): Promise<T>;
    execute(query: string): Promise<void>;
    query(query: string, args?: QueryArgs): Promise<Set>;
    queryJSON(query: string, args?: QueryArgs): Promise<string>;
    queryOne(query: string, args?: QueryArgs): Promise<any>;
    queryOneJSON(query: string, args?: QueryArgs): Promise<string>;
    close(): Promise<void>;
    isClosed(): boolean;
    terminate(): void;
    private _warn_on_long_close;
}
export declare function createPool(dsn?: string | PoolOptions | null, options?: PoolOptions | null): Promise<Pool>;
export {};
