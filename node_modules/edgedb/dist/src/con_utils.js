"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const url = require("url");
const os = require("os");
const credentials_1 = require("./credentials");
const EDGEDB_PORT = 5656;
function mapParseInt(x) {
    const res = parseInt(x, 10);
    if (isNaN(res)) {
        throw new Error("could not convert " + JSON.stringify(x) + " to an integer");
    }
    return res;
}
function parseConnectArguments(opts = {}) {
    if (opts.command_timeout != null) {
        if (typeof opts.command_timeout !== "number" || opts.command_timeout < 0) {
            throw new Error("invalid command_timeout value: " +
                "expected greater than 0 float (got " +
                JSON.stringify(opts.command_timeout) +
                ")");
        }
    }
    return {
        ...parseConnectDsnAndArgs(opts),
        connect_timeout: opts.timeout,
        command_timeout: opts.command_timeout,
    };
}
exports.parseConnectArguments = parseConnectArguments;
function parseConnectDsnAndArgs({ dsn, host, port, user, password, database, admin, server_settings, }) {
    var _a;
    if (admin) {
        console.warn("The `admin: true` parameter is deprecated and is scheduled " +
            "to be removed. Admin socket should never be used in " +
            "applications. Use command-line tool `edgedb` to setup " +
            "proper credentials.");
    }
    if (dsn && /^edgedb(?:admin)?:\/\//.test(dsn)) {
        const dsnHostMatch = /\/\/(.+?@)?(.*)\//.exec(dsn);
        let dsnHost = null;
        if (dsnHostMatch && typeof dsnHostMatch[2] === "string") {
            dsnHost = dsnHostMatch[2];
            if (dsnHost.indexOf(",") !== -1) {
                let rep;
                if (dsnHostMatch[1]) {
                    rep = "@";
                }
                else {
                    rep = "//";
                }
                dsn = dsn.replace(rep + dsnHost + "/", rep + "replaced_host/");
            }
            else {
                dsnHost = null;
            }
        }
        const parsed = url.parse(dsn, true);
        if (typeof parsed.protocol === "string") {
            if (parsed.protocol === "edgedbadmin:") {
                console.warn("The `edgedbadmin` scheme is deprecated and is scheduled " +
                    "to be removed. Admin socket should never be used in " +
                    "applications. Use command-line tool `edgedb` to setup " +
                    "proper credentials.");
            }
            if (["edgedb:", "edgedbadmin:"].indexOf(parsed.protocol) === -1) {
                throw new Error("invalid DSN: scheme is expected to be " +
                    '"edgedb" or "edgedbadmin", got ' +
                    (parsed.protocol ? parsed.protocol.slice(0, -1) : parsed.protocol));
            }
        }
        else {
            throw new Error("invalid DSN: scheme is expected to be " +
                '"edgedb" or "edgedbadmin", but it\'s missing');
        }
        if (admin == null) {
            admin = parsed.protocol === "edgedbadmin:";
        }
        if (!host && parsed.host) {
            if (dsnHost) {
                [host, port] = parseHostlist(dsnHost, port);
            }
            else {
                host = (_a = parsed.hostname, (_a !== null && _a !== void 0 ? _a : undefined));
                if (parsed.port) {
                    port = parseInt(parsed.port, 10);
                }
            }
        }
        if (parsed.pathname && database == null) {
            database = parsed.pathname;
            if (database[0] === "/") {
                database = database.slice(1);
            }
        }
        if (parsed.auth) {
            const [puser, ppass] = parsed.auth.split(":");
            if (puser && user == null) {
                user = puser;
            }
            if (ppass && password == null) {
                password = ppass;
            }
        }
        if (parsed.query) {
            if ("port" in parsed.query) {
                if (!port && parsed.query.port) {
                    let pport;
                    if (parsed.query.port instanceof Array) {
                        pport = parsed.query.port[parsed.query.port.length - 1];
                    }
                    else {
                        pport = parsed.query.port;
                    }
                    port = pport.split(",").map(mapParseInt);
                }
                delete parsed.query.port;
            }
            if ("host" in parsed.query) {
                if (!host && parsed.query.host) {
                    [host, port] = parseHostlist(parsed.query.host, port);
                }
                delete parsed.query.host;
            }
            const parsedQ = {};
            for (const key of Object.keys(parsed.query)) {
                const param = parsed.query[key];
                if (typeof param === "string") {
                    parsedQ[key] = param;
                }
                else {
                    parsedQ[key] = param ? param.pop() : "";
                }
            }
            if ("dbname" in parsedQ) {
                if (!database) {
                    database = parsedQ.dbname;
                }
                delete parsedQ.dbname;
            }
            if ("database" in parsedQ) {
                if (!database) {
                    database = parsedQ.database;
                }
                delete parsedQ.database;
            }
            if ("user" in parsedQ) {
                if (!user) {
                    user = parsedQ.user;
                }
                delete parsedQ.user;
            }
            if ("password" in parsedQ) {
                if (!password) {
                    password = parsedQ.password;
                }
                delete parsedQ.password;
            }
            if (Object.keys(parsedQ).length) {
                if (server_settings == null) {
                    server_settings = { ...parsedQ };
                }
                else {
                    server_settings = { ...parsedQ, ...server_settings };
                }
            }
        }
    }
    else if (dsn) {
        if (!/^[A-Za-z_][A-Za-z_0-9]*$/.test(dsn)) {
            throw Error(`dsn "${dsn}" is neither a edgedb:// URI nor valid instance name`);
        }
        const credentials_file = path.join(os.homedir(), ".edgedb", "credentials", dsn + ".json");
        const credentials = credentials_1.readCredentialsFile(credentials_file);
        port = credentials.port;
        user = credentials.user;
        if (host == null && "host" in credentials) {
            host = credentials.host;
        }
        if (password == null && "password" in credentials) {
            password = credentials.password;
        }
        if (database == null && "database" in credentials) {
            database = credentials.database;
        }
    }
    if (!host) {
        const hostspec = process.env.EDGEDB_HOST;
        if (hostspec) {
            const hl = parseHostlist(hostspec, port);
            host = hl[0];
            port = hl[1];
        }
        else {
            if (process.platform === "win32") {
                host = [];
            }
            else {
                host = ["/run/edgedb", "/var/run/edgedb"];
            }
            if (!admin) {
                host.push("localhost");
            }
        }
    }
    else if (!(host instanceof Array)) {
        host = [host];
    }
    if (!port) {
        const portspec = process.env.EDGEDB_PORT;
        if (portspec) {
            port = portspec.split(",").map(mapParseInt);
        }
        else {
            port = EDGEDB_PORT;
        }
    }
    port = validatePortSpec(host, port);
    if (!user) {
        user = process.env.EDGEDB_USER;
    }
    if (!user) {
        throw new Error("could not determine user name to connect with");
    }
    if (!password) {
        password = process.env.EDGEDB_PASSWORD;
    }
    if (!database) {
        database = process.env.EDGEDB_DATABASE;
    }
    if (!database) {
        database = user;
    }
    if (!database) {
        throw new Error("could not determine database name to connect to");
    }
    let haveUnixSockets = false;
    const addrs = [];
    for (let i = 0; i < host.length; i++) {
        let h = host[i];
        const p = port[i];
        if (h[0] === "/") {
            if (h.indexOf(".s.EDGEDB.") === -1) {
                let sockName;
                if (admin) {
                    sockName = ".s.EDGEDB.admin." + p;
                }
                else {
                    sockName = ".s.EDGEDB." + p;
                }
                h = path.join(h, sockName);
                haveUnixSockets = true;
            }
            addrs.push(h);
        }
        else if (!admin) {
            addrs.push([h, p]);
        }
    }
    if (admin && !haveUnixSockets) {
        throw new Error("admin connections are only supported over UNIX sockets");
    }
    if (addrs.length === 0) {
        throw new Error("could not determine the database address to connect to");
    }
    return {
        addrs,
        user,
        password,
        database,
        server_settings,
    };
}
function parseHostlist(hostlist, inputPort) {
    let hostspecs;
    const hosts = [];
    const hostlist_ports = [];
    let default_port = [];
    let ports = [];
    if (hostlist instanceof Array) {
        hostspecs = hostlist;
    }
    else {
        hostspecs = hostlist.split(",");
    }
    if (!inputPort) {
        const portspec = process.env.EDGEDB_PORT;
        if (portspec) {
            default_port = portspec.split(",").map(mapParseInt);
            default_port = validatePortSpec(hostspecs, default_port);
        }
        else {
            default_port = validatePortSpec(hostspecs, EDGEDB_PORT);
        }
    }
    else {
        ports = validatePortSpec(hostspecs, inputPort);
    }
    for (let i = 0; i < hostspecs.length; i++) {
        const [addr, hostspec_port] = hostspecs[i].split(":");
        hosts.push(addr);
        if (!inputPort) {
            if (hostspec_port) {
                hostlist_ports.push(mapParseInt(hostspec_port));
            }
            else {
                hostlist_ports.push(default_port[i]);
            }
        }
    }
    if (!inputPort) {
        ports = hostlist_ports;
    }
    return [hosts, ports];
}
function validatePortSpec(inputHosts, inputPort) {
    let ports;
    if (inputPort instanceof Array) {
        if (inputPort.length !== inputHosts.length) {
            throw new Error("could not match " +
                inputPort.length +
                " port numbers to " +
                inputHosts.length +
                " hosts");
        }
        ports = inputPort;
    }
    else {
        ports = Array(inputHosts.length).fill(inputPort);
    }
    ports = ports.map(mapParseInt);
    return ports;
}
