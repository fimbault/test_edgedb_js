"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const compat_1 = require("../compat");
const bi = require("../bigint");
const dateutil_1 = require("./dateutil");
exports.DATE_PRIVATE = Symbol.for("edgedb.datetime");
class LocalDateTime {
    constructor(year, month = 0, day = 0, hour = 0, minute = 0, second = 0, millisecond = 0) {
        if (month === exports.DATE_PRIVATE &&
            year instanceof Date) {
            this._date = year;
        }
        else {
            this._date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
        }
    }
    getTime() {
        return this._date.getTime();
    }
    getDate() {
        return this._date.getUTCDate();
    }
    getDay() {
        return this._date.getUTCDay();
    }
    getFullYear() {
        return this._date.getUTCFullYear();
    }
    getHours() {
        return this._date.getUTCHours();
    }
    getMilliseconds() {
        return this._date.getUTCMilliseconds();
    }
    getMinutes() {
        return this._date.getUTCMinutes();
    }
    getMonth() {
        return this._date.getUTCMonth();
    }
    getSeconds() {
        return this._date.getUTCSeconds();
    }
    toDateString() {
        return this.toString();
    }
    toISOString() {
        const result = this._date.toISOString();
        if (result[result.length - 1] !== "Z") {
            throw new Error(`unexpected ISO format: ${result}`);
        }
        return result.slice(0, -1);
    }
    toJSON() {
        return this.toISOString();
    }
    valueOf() {
        return this._date.valueOf();
    }
    toString() {
        const result = this._date.toUTCString();
        if (result.slice(-4) !== " GMT") {
            throw new Error(`unexpected UTC format: ${result}`);
        }
        return result.slice(0, -4);
    }
    toDateTime() {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
    }
    [compat_1.inspect.custom](_depth, _options) {
        return `LocalDateTime [ ${this.toISOString()} ]`;
    }
}
exports.LocalDateTime = LocalDateTime;
class LocalTime {
    constructor(hours, minutes = 0, seconds = 0, milliseconds = 0) {
        if (hours < 0 || hours > 23) {
            throw new Error(`invalid number of hours ${hours}: expected a value in 0-23 range`);
        }
        if (minutes < 0 || minutes > 59) {
            throw new Error(`invalid number of minutes ${minutes}: expected a value in 0-59 range`);
        }
        if (seconds < 0 || seconds > 59) {
            throw new Error(`invalid number of seconds ${seconds}: expected a value in 0-59 range`);
        }
        if (milliseconds < 0 || milliseconds > 999) {
            throw new Error(`invalid number of milliseconds ${milliseconds}: ` +
                `expected a value in 0-999 range`);
        }
        this._hours = hours;
        this._minutes = minutes;
        this._seconds = seconds;
        this._milliseconds = milliseconds;
    }
    getHours() {
        return this._hours;
    }
    getSeconds() {
        return this._seconds;
    }
    getMilliseconds() {
        return this._milliseconds;
    }
    getMinutes() {
        return this._minutes;
    }
    valueOf() {
        return this.toString();
    }
    toString() {
        const hh = this._hours.toString().padStart(2, "0");
        const mm = this._minutes.toString().padStart(2, "0");
        const ss = this._seconds.toString().padStart(2, "0");
        let repr = `${hh}:${mm}:${ss}`;
        if (this._milliseconds) {
            repr += `.${this._milliseconds}`.replace(/(?:0+)$/, "");
        }
        return repr;
    }
    [compat_1.inspect.custom](_depth, _options) {
        return `LocalTime [ ${this.toString()} ]`;
    }
}
exports.LocalTime = LocalTime;
class LocalDate {
    constructor(year, monthIndex = 0, day = 1) {
        if (monthIndex < 0 || monthIndex >= 12) {
            throw new Error(`invalid monthIndex ${monthIndex}: expected a value in 0-11 range`);
        }
        const maxDays = dateutil_1.daysInMonth(year, monthIndex + 1);
        if (monthIndex < 0 || monthIndex >= 12 || day < 1 || day > maxDays) {
            throw new Error(`invalid number of days ${day}: ` +
                `expected a value in 1..${maxDays} range`);
        }
        this._year = year;
        this._month = monthIndex;
        this._day = day;
    }
    getFullYear() {
        return this._year;
    }
    getMonth() {
        return this._month;
    }
    getDate() {
        return this._day;
    }
    valueOf() {
        return this.toString();
    }
    toString() {
        const mm = (this._month + 1).toString().padStart(2, "0");
        const dd = this._day.toString().padStart(2, "0");
        return `${this._year}-${mm}-${dd}`;
    }
    [compat_1.inspect.custom](_depth, _options) {
        return `LocalDate [ ${this.toString()} ]`;
    }
    toOrdinal() {
        return dateutil_1.ymd2ord(this._year, this._month + 1, this._day);
    }
    static fromOrdinal(ord) {
        const [year, month, day] = dateutil_1.ord2ymd(ord);
        return new this(year, month - 1, day);
    }
}
exports.LocalDate = LocalDate;
class Duration {
    constructor(milliseconds = 0, microseconds = bi.make(0)) {
        this._microseconds = bi.add(bi.make(Math.floor(milliseconds * 1000)), microseconds);
    }
    static fromMicroseconds(microseconds) {
        return new Duration(undefined, microseconds);
    }
    toSeconds() {
        return Number(this._microseconds) / 1000000;
    }
    toMilliseconds() {
        return Number(this._microseconds) / 1000;
    }
    toMicroseconds() {
        return this._microseconds;
    }
    toString() {
        const buf = [];
        const micros = this._microseconds;
        const bint_hour = bi.div(micros, bi.make(3600000000));
        let time = Number(bi.sub(micros, bi.mul(bint_hour, bi.make(3600000000))));
        const hour = Number(bint_hour);
        const tfrac = Math.trunc(time / 60000000);
        time -= tfrac * 60000000;
        const min = tfrac;
        const sec = Math.trunc(time / 1000000);
        let fsec = time - sec * 1000000;
        const neg = hour < 0 || min < 0 || sec < 0 || fsec < 0;
        buf.push(`${neg ? "-" : ""}` +
            `${Math.abs(hour)
                .toString()
                .padStart(2, "0")}:` +
            `${Math.abs(min)
                .toString()
                .padStart(2, "0")}:` +
            `${Math.abs(sec)
                .toString()
                .padStart(2, "0")}`);
        fsec = Math.abs(fsec);
        if (fsec) {
            fsec = Math.round(fsec);
            buf.push(`.${fsec.toString().padStart(6, "0")}`.replace(/(0+)$/, ""));
        }
        return buf.join("");
    }
    [compat_1.inspect.custom](_depth, _options) {
        return `Duration [ ${this.toString()} ]`;
    }
}
exports.Duration = Duration;
